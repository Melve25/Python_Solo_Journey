## Декораторы

И так давайте разберём что такое декораторы. По сути это те же методы, только принимают они в себя вместо переменных, другие функции, разберём на примере, напишем декоратор который просто пишет любой текст

> Пример:
> 
> 
> ```python
> def add_some_text(func):
> 	def wrapper():
> 		print(123)
> 		func()
> 	return wrapper
> ```
> 

И так, помимо того что функцию мы можем передать, в другую, мы еще можем ее вернуть, как бы не вызывая её. Функция **wprapper()** как раз таки служит оберткой, добавляет функционал либо как в нашем случае текст, вызывает функцию которую мы передали, а затем возвращает все это назад. Данный декоратор запустится при выполнении функции которую мы задекорировали

> Пример:
> 
> 
> ```python
> def add_some_text(func):
> 	def wrapper():
> 		print(123)
> 		func()
> 	return wrapper
> 	
> @add_some_text
> def print_name():
> 	print("hello Max")
> 	
> print_name()
> 
> # output
> 123
> hello Max
> ```
> 

В ответе мы получим то что прописали во **wrapper()**, мы этот порядок можем и менять, если такое требуется.

---

Давайте разберем более сложный случай, посчитаем время затраченное на выполнение функции.

> Пример:
> 
> 
> ```python
> def count_time(func):
> 	def wrapper():
> 		t1 = time.time()
> 		func()
> 		t2 = time.time()-t1
> 		print(f"It took {t2} seconds")
> 	return wrapper
> 	
> @count_time
> def do_something():
> 	time.sleep(1.2)
> ```
> 

В данном примере простой подсчёт времени, начало отсчета, потом вызов функции, ждем пока она закончится и вычитаем время, это и будет результатом, такой декоратор можно использовать на любой функции которая у вас есть, для тестов на затраченное время.

---

Теперь стоит разобрать декораторы с функциями в которых есть аргументы, для этого нужно использовать ***args** и ****kwargs**:

> Пример:
> 
> 
> ```python
> def mult_result(func):
> 	def wrapper(*args, **kwargs):
> 		print("started")
> 		val = func(*args, **kwargs) * 2
> 		print("ended")
> 		return val
> 		
> 	return wrapper
> 
> @mult_result
> def add(x, y) -> int:
> 	return x + y
> 	
> print(add(4, 2))
> # output
> 12
> ```
> 

В данном примере становится понятно, что отработка функции переходит во wrapper(), вместе со всеми аргументами которые только могли бы быть, и мы записываем затем изменяем, и возвращаем новое значение, заметим что мы не использовали ****kwargs**, и это совершенно не обязательно передавать, просто показал, что мы можем передать все виды аргументов.

---

Пришло время для сложных вариантов, так вот, декораторы сами могут принимать аргументы, и для этого нужно изменить привычную структуру декораторов, их станет несколько в одном.

Пропишем декоратор который просто информирует о вызове функции и сообщает о уровне важности:

> Пример:
> 
> 
> ```python
> def log(level):
> 	def decorator(func):
> 		def wrapper(*args, **kwargs):
> 			print(f"[{level.upper()}] Вызов функции: {func.__name__}")
> 			return func(*args, **kwargs)
> 		return wrapper
> 	return decorator
> 	
> @log("owner")
> def greet(name):
>     print(f"Привет, {name}!")
> 
> greet("Max")
> 
> # output
> [OWNER] Вызов функции: greet
> Привет, Max!
> ```
> 

И так, у нас есть log() который принимает в себя переменные с декоратора, после чего идет наш самый обычный декоратор, обертка с аргументами, печатаем инфу, возвращаем функцию, и возвращаем wrapper, и в конце концов возвращаем сам декоратор.  Все просто, у нас появился лишь еще один уровень чуть выше самого декоратора, который попросту принимает переменные переданные в декоратор в момент декорирования.