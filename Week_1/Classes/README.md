## Classes, __**init__**, self, methods, __**dunder_methods**__

Разберем ООП в Python. 

Классы в python создаются весьма просто, в названии всегда используем CamelCase.

> Пример:
> 
> 
> ```python
> class Monitor:
> 	def __init__(self, brand:str, resolution:str) -> None:
> 		self.brand = brand
> 		self.resolution = resolution
> 		
> sony: Monitor = Monitor("sony", "1920x1080")
> ```
> 

Для начала разберем что такое **self**. В примере видно, что мы создали сущность **“sony”**, и передали в класс 2 переменные, это бренд и разрешение. Так вот этот самый **self** можно представить в виде того же **“sony”**. То есть:

> Пример:
> 
> 
> ```python
> class Monitor:
> 	def __init__(sony, brand:str, resolution:str) -> None:
> 		sony.brand = brand
> 		sony.resolution = resolution
> 		
> sony: Monitor = Monitor("sony", "1920x1080")
> ```
> 

Создавая другую сущность, она как бы подставляется вместо **self**. 

---

Теперь когда мы создали объект **sony,** мы можем обратится к его данным, а если точно то **brand** и **resolution**. 

> Пример:
> 
> 
> ```python
> print(sony.brand)
> print(sony.resolution)
> 
> # output
> sony
> 1920x1080
> ```
> 

---

## Methods

Помимо основного метода __**init**__, который является стандартным, и служит для инициализации класса, без него невозможно создание объектов с присвоением к ним данным.

Можно так же создавать свои собственные методы, давайте рассмотрим включение  и выключение:

> Пример:
> 
> 
> ```python
> class Monitor:
> 	def __init__(self, brand:str, resolution:str) -> None:
> 		self.brand = brand
> 		self.resolution = resolution
> 		self.turned_on: bool = False
> 		
> 	def turn_on(self) -> None:
> 		if self.turned_on:
> 			print(f"Monitor ({self.brand}) is already turned on.")
> 		else:
> 			self.turned_on = True
> 			print(f"Monitor ({self.brand}) is now turned on.")
> 			
> 			
> 	def turn_off(self) -> None:
> 		if self.turned_on:
> 			self.turned_on = False
> 			print(f"Monitor ({self.brand}) is now turned off.")
> 		else:
> 			print(f"Monitor ({self.brand}) is already turned off.")
> ```
> 

Во первых стоит добавить переменную состояния **turned_on**, и дадим ей дефолтное состояние **False**, чтобы не приходилось передавать в объект информацию о включении монитора.  И создадим 2 метода **turn_on** и turn_off, так же стоит заметить что в них мы тоже передаем **self**, иначе оперировать нашим объектом не получится. Теперь создаем простое условие, если монитор включен то сообщаем об этом, если нет включаем и сообщаем об этом, и наоборот для выключения.

Теперь методы нужно вызвать, делается это весьма просто:

> Пример:
> 
> 
> ```python
> sony.turn_on()
> sony.turn_off()
> 
> # output
> Monitor (sony) is already turned off.
> Monitor (sony) is now turned on.
> ```
> 
> Собственные методы вызываются через точку названия метода и скобок в конце
> 

---

В методы так же можно и передавать переменные, давайте создадим простой метод включением каналов:

> Пример:
> 
> 
> ```python
> def choose_chanel(self, chanel: int) -> None:
> 	if self.turned_on:
> 		print(f"Канал {chanel} включен")
> 	else:
> 		print(f"Монитор не реагирует, он выключен")
> ```
> 

Теперь вызовем метод

> Пример:
> 
> 
> ```python
> sony.choose_chanel(2)
> sony.turn_on()
> sony.choose_chanel(2)
> 
> # output
> Монитор не реагирует, он выключен
> Monitor (sony) is now turned on.
> Канал 2 включен
> ```
> 

Все весьма просто, точно так же как и в других встроенных методах python, просто передаем переменные в скобках метода

---

## Dunder Methods

Перед тем как начать объяснение, давайте попробуем кое что сделать, добавим еще один монитор, и соединим их: 

> Пример:
> 
> 
> ```python
> print(sony + huion)
> ```
> 

Сходу появится ошибку, компилятор не поймет что ему делать с этими 2 объектами, он не знает как их складывать, но хорошая новость, такие методы мы тоже можем прописать.

Данные методы предусмотрены уже в самом python, например метод __**add**__ который мы рассмотрим, а именно сложение, изначально этот метод ничего не делает он пустой.

Теперь давай пропишем в нем инструкции:

> Пример:
> 
> 
> ```python
> def __add__(self, other): 
> 	return f"{self.brand} + {other.brand}"
> 	
> print(sony + huion)
> 
> # output
> sony + huion
> ```
> 

Мы перезаписали правила сложения для данного класса, он вернул нам строку, но по сути вернуть он может что угодно, все что мы пропишем туда, это может быть даже сущность другого класса.

---

Давайте рассмотрим более интересный пример со строкой __**str**__:

> Пример:
> 
> 
> ```python
> def __str__(self) -> str: 
> 	return f"{self.brand} + (Resolution: {self.resolution})"
> 	
> print(sony)
> 
> # output
> sony + (Resolution: 1920x1080)
> ```
> 

Теперь при попытке напечатать сам объект, мы получим читаемые данные, которые сами прописали, в противном случае, не указав этого метода, все что мы прочли это в какой ячейке памяти хранится данный объект. Вот так вот мы можем переписывать внутренние методы, которые не требуют вызывать себя через точку и скобки, из за чего они еще зовутся магическими методами. 

Также же у нас есть еще один важный метод __**repr**__, изначально информацию о ячейке памяти выдает именно он, это его дефолтная функция, но мы можем его переопределить, чтобы разработку дать больше информации о том что вообще наш класс из себя представляет, в то время как __**str**__ дает более юзерфрендли информацию, __**repr**__ дает информацию именно для разработчика

> Пример:
> 
> 
> ```python
> def __repr__(self) -> str: 
> 	return f"class Monitor: (brand='{self.brand}' resolution='{self.resolution}')"
> 	
> print(repr(sony))
> 
> # output
> class Monitor: (brand='sony' resolution='1920x1080')
> ```
>